#пагинация #фильтрация #alchemy #подстрока

Чаще используеться в [[SELECT эндпоинты через SQLAlchemy]] 

Как выглядит запрос на языке SQL:
```SQL
SELECT id, title, location
FROM hotels
WHERE id = 1 and title = "название отеля"
LIMIT 5
OFFSET 0;
```

Запрос на языке алхимии с явным указанием query - параметров:
```python
from fastapi import Query, FastAPI, Depends
import asyncio
from sqlalchemy import select
from src.database import async_session_maker
from src.models.hotels import HotelsORM
from pydantic import BaseModel  
from typing import Annotated  
  
  
class PaginationParams(BaseModel):  
    page: Annotated[int | None, Query(default=1, gt=0)]  
    per_page: Annotated[int | None, Query(default=None, gt=0, lt=30)]  
  
  
PaginationDep = Annotated[PaginationParams, Depends()]

app= FastAPI()

# Запрос с явным указанием параметров
@app.get("/hotels", summary="Вернуть информацию об отелях")  
async def get_hotels(
	pagination: PaginationDep,  
	hotel_id: int | None = Query(default=None, description="ID-номер"),  
	title: str | None = Query(default=None, description="Название отеля"),
):  
    async with async_session_maker() as session:
		query = (
			select(HotelORM)
			.filter_by(id=id, title=title)
			.limit(pagination.per_page)
			.offset(pagination.per_page * (pagination.page - 1))
		)
	    result = await session.execute(query)
	    hotels = result.scalars().all()
	    return hotels
	    
# Запрос с неявным указанием параметров
@app.get("/hotels", summary="Вернуть информацию об отелях")  
async def get_hotels(
	pagination: PaginationDep,  
	hotel_id: int | None = Query(default=None, description="ID-номер"),  
	title: str | None = Query(default=None, description="Название отеля"),
):  
	per_page = pagination.per_page or 5 # делаем так, чтобы задать параметр по умолчанию в случае, если у объекта не будет атрибута per_page
    async with async_session_maker() as session:
	    query = select(HotelORM)
	    
	    if id is not None:
		    query = query.filter_by(id=id)
	    if title is not None:
		    query = query.filter_by(title=title)
		    
		query = (
			query.limit(per_page)
			.offset(per_page * (pagination.page - 1))
		)
		
	    result = await session.execute(query)
	    hotels = result.scalars().all()
	    return hotels
```
Порядок действий такой же, как в SQL, сначала фильтруем, потом выдаём.
query = (
	<mark style="background: #BBFABBA6;">select</mark>(HotelORM) # идёт работа с таблицей hotels (моделью)
	.<mark style="background: #BBFABBA6;">filter_by</mark>(id=id, title=title) # фильтрация по полям
	.<mark style="background: #BBFABBA6;">limit</mark>(pagination.per_page) # кол-во выводимых запросов
	.<mark style="background: #BBFABBA6;">offset</mark>(pagination.per_page * (pagination.page - 1)) # вывод начиная с offset позиции limit запросов
)

## Фильтрация по подстроке

Пример на языке SQL:
```SQL
SELECT id, title, location
FROM hotels
WHERE id LIKE "%подстрока%"
```

В алхимии:
```python
async def get_hotels(
	hotel_id: int | None = Query(default=None, description="ID-номер"),  
	title: str | None = Query(default=None, description="Название отеля"),
):  
	async with async_session_maker() as session:  
	    query = alh.select(HotelsORM)  
	    
	    query = query.filter(HotelsORM.location.like(f"%{location}%"))   
	    query = query.filter(HotelsORM.title.ilike(f"%{title}%"))  
	    
	    result = await session.execute(query)  
	    return result.scalars().all()
```
Чтобы воспользоваться фильтрацией по подстроке используется метод <mark style="background: #FF5582A6;">filter вместо filter_by</mark>.
Вместо обычного поля указываем название модели с его атрибутом (поля, по которому будем искать) filter(<mark style="background: #FF5582A6;">HotelsORM.location</mark> ...), далее указываем метод like / ilike, который отвечает за фильтрацию по подстроке (i указывает на поиск без учёта регистра).

Вместо метода like / ilke можно воспользоваться методом .contains(), что означает содержит:

```python
query = query.filter(HotelsORM.location.contains(location.strip().lower()))   
```
