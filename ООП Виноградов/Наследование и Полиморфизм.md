Код:

	#include <iostream>
	#include <string>
	#include <conio.h>
	
	using namespace std;
	
	class base {
	private:
		string name;
		
		void vvodName() {
			cout  << "input name" ;
			cin >> name;
	}

	public:
		base() {
			vvodName();
		};
		
		void print () {
			cout << "name=" << name;
		}
	};
	
	class child:: public base {
	private:
		int age;
		
		void setAge() {
			cout << "Age=" ;
			cin >> age;
		}
	
	public:
		child () {
			setAge();
		}
	
		void print() {
			base::print();
			cout << "age:" << age;
		}
		};
	
	int main {
		child.q1;
		q1.print();
		_getch();
		return 0;
	}

Продолжение темы наследования:

	#include <iostream>
	#include <conio.h>
	#include <string>
	
	using namespace std;
	
	class base {
	protected: // защищенный атрибут, который обеспечивает доступ ко всем наследникам.
		string name;
		
	public:
		base(){
			cout << "i am a base" << endl;
			setName();
		}
		
		void setName(){
			cout << "name=";
			cin >> name;
		}
		
		string getName() const{
			return name;
		}
		
		
	}
	
	class child :private base{ // все поля из base станут приватными в child
	private:
		int age;
		
		void setAge(){
			cout << "name: " << getName() << " input age = "; // можно использовать просто name для получения имени.
			cin >> age;
		}
		
	public:
		child(){
			cout << "i am a child" << endl;
			setAge();
		}
		
		int getAge() const{
			return age;
		}
		
		void printInfo(){
			cout << "name" << getName() << " age: " << age << endl;
		}
	}
	
	void print(child x[], int n){
		for (int i = 0; i < n; i++){
			x[i].printInfo();
		}
	}
	
	
	int main(){
		child q1;
		q1.printInfo();
		
		child q[2];
		print(q, 2);
		_getch();
		return 0;
	}

Сначала отрабатывает конструктор базового класса, а после уже конструктор дочернего класса.
Без наследования нет полиморфизма, а на наследование невозможно без инкапсуляции.

Полиморфизм.

	#include <iostream>
	#include <string>
	#include <conio.h>
	
	using namespace std;
	
	class base {
	private:
		string name;
		
		void vvodName() {
			cout  << "input name" ;
			cin >> name;
	}

	public:
		base() {
			vvodName();
		};
		
		void print () {
			cout << "name=" << name;
		}
	};
	
	class child:: public base {
	private:
		int age;
		
		void setAge() {
			cout << "Age=" ;
			cin >> age;
		}
	
	public:
		child () {
			setAge();
		}
	
		void print() {
			base::print();
			cout << "age:" << age;
		}
		};
	
	int main {
		child.q1;
		q1.print();
		_getch();
		return 0;
	}

Продолжение темы наследования:

	#include <iostream>
	#include <conio.h>
	#include <string>
	
	using namespace std;
	
	class base {
	private:
		string name;
		int age;
		
		void setAge(){
			cout << "age = ";
			cin >> age;
		}
		
		void setName(){
			cout << "name=";
			cin >> name;
		}
		
	public:
		base(){
			setName();
			setAge();
		}
		
		string getName() const{
			return name;
		}
		
		int getAge() const{
			return age;
		}
		
		void changeAge(){
			cout << "name: "<< name << " new age= ";
			cin >> age;
		}
		
		void print_info(){
			cout << "name:" << name << "age:" << age << endl;
		}
		
		void speak(){
			cout << "i am speaking" << endl;
		}
		
	}
	
	class dog :public bas{
	public:
		void speak()}{
			cout << "gav gav" << endl;
		}
	}
	
	class dog :public bas{
	public:
		void speak(){
			cout << "meow meow" << endl;
		}
	}
	
	int main(){
		child q1;
		q1.printInfo();
		
		child q[2];
		print(q, 2);
		_getch();
		return 0;
	}