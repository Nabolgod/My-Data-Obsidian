Допустим есть какой-то объект P и есть объект Q одного и того же класса. Вопрос, что будет если мы один объект прибавим к другому?
На уровне программы будет ошибка, т.к. нет инструкции для этой операции.

Результатом такой операции может быть то, что "запрограммирует программист". Может быть новый объект или будет изменён текущий объект. Нужно понимать зачем вообще такая операция.
```cpp
include <iostream>
include <string>
include <conio.h>

using namespace std;

class example{
private:
	string name;
	int x;
	
	void setName(){
		cout << "input name=";
		cin >> name;
	}
	
	void setX(){
		cout << "input x=";
		cin >> x;		
	}
	
public:
	example(){
		setName();
		setX();
	}
	
	string getName(){
		return name;
	}
	
	string getX(){
		return x;
	}
	
	void print(){
		cout << "name: " << name << "x: " << x << endl;
	}
}

int main(){
	setlocale(LC, "RU");
	
	example q;
	example g;
	
	example res = q + g; # ошибка
	int = q + g; # ошибки нет
	
	_getch();
	return 0;
}
```

Есть несколько способов работы с операциями:
1) Первое, реализация вне класса для работы с разными объектами даже если они одного класса.
```cpp
example operator + (example a, example b){
	example w;
	w.x = a.get() + b.get(); # ошибка т.к нет доступа к x
	return a.get() + b.get();
}

example operator + (example a, example b){
	example w;
	w.x = a.x + b.x; # ошибка нет, если x находится в public
	return w;
}
```
Инфиксный - значит между операндами.
Конструкция <mark style="background: #ABF7F7A6;">operator </mark>говорит о том, что сейчас будет перегрузка оператора (мы по сути учим оператор + делать ещё одно действие).
В таком подходе всё плохо, так как нет доступа к полям. 

Перегрузку внутри класса надо делать, когда мы возвращаем новый объект текущего класса или изменяем текущий объект.

2) Второй вариант перегружать конструктор внутри класса.
```cpp
class example{
private:
	string name;
	int x;
	
	void setName(){
		cout << "input name=";
		cin >> name;
	}
	
	void setX(){
		cout << "input x=";
		cin >> x;		
	}
	
public:
	example(){
		setName();
		setX();
	}
	
	string getName(){
		return name;
	}
	
	string getX(){
		return x;
	}
	
	void print(){
		cout << "name: " << name << "x: " << x << endl;
	}
	
	example operator + (example a){
		example w;
		w.x = a.x + x;
		return w;
	}
}
```
Этот метод позволяет придерживаться инкапсуляции и описывать логику сложения объектов.

3) Третий способ через указатель
```cpp
class example{
...
	example &operator + (example a){
		x = a.x + x;
		return *this;
	}
}

int main(){
...
	example q, g;
	q + g;
	q.print();
	g.print();
...
}
```
В результате такого суммирования будет возвращён текущий объект (\*this).
Также изменится поле текущего объекта.