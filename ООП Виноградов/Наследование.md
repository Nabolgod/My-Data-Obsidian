Код:

	#include <iostream>
	#include <string>
	#include <conio.h>
	
	using namespace std;
	
	class base {
	private:
		string name;
		
		void vvodName() {
			cout  << "input name" ;
			cin >> name;
	}

	public:
		base() {
			vvodName();
		};
		
		void print () {
			cout << "name=" << name;
		}
	};
	
	class child:: public base {
	private:
		int age;
		
		void setAge() {
			cout << "Age=" ;
			cin >> age;
		}
	
	public:
		child () {
			setAge();
		}
	
		void print() {
			base::print();
			cout << "age:" << age;
		}
		};
	
	int main {
		child.q1;
		q1.print();
		_getch();
		return 0;
	}

Продолжение темы наследования:

	#include <iostream>
	#include <conio.h>
	#include <string>
	
	using namespace std;
	
	class base {
	protected: // защищенный атрибут, который обеспечивает доступ ко всем наследникам.
		string name;
		
	public:
		base(){
			cout << "i am a base" << endl;
			setName();
		}
		
		void setName(){
			cout << "name=";
			cin >> name;
		}
		
		string getName() const{
			return name;
		}
		
		
	}
	
	class child :private base{ // все поля из base станут приватными в child
	private:
		int age;
		
		void setAge(){
			cout << "name: " << getName() << " input age = "; // можно использовать просто name для получения имени.
			cin >> age;
		}
		
	public:
		child(){
			cout << "i am a child" << endl;
			setAge();
		}
		
		int getAge() const{
			return age;
		}
		
		void printInfo(){
		
		}
	}
	
	int main(){
		child q1;
		
		
		_getch();
		return 0;
	}

Сначала отрабатывает конструктор базового класса, а после уже конструктор дочернего класса.